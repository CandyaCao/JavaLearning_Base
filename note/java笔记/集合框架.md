## 集合框架
集合框架是在jdk1.2之后才出现的
没有集合框架的时候，我们对数据的操作需要自己去封装完成，违背了拿来主义。
不符合DRY原则。
拿来主义
----容器类：
在没有集合框架的时候，也给定义了一些简单的容器。
vector、Stack、Queue

数组存在弊端
1. 长度：一旦初始化，长度不能改
2. 在项目中很多地方都要使用数组，所以会出现大量冗余的代码，那我们就需要自己对数据做封装，不符合DRY原则
3. 每个人对数组操作的类名或方法名或实现细节都不同，很难维护
4. 数组只能放同种数据类型，当然，可以定义object类型的数组，但是会有类型不安全的隐患。

SUN公司提供了几个封装好的容器类，我们只需要调用就好了

## 为啥要有集合框架
虽然这些容器很好用，但不能集中和统一管理。集合框架就是为表示和操作集合而规定的一套体系结构，任何集合类都会包含三部分内容，对外的接口，接口的实现、对集合运算的算法。

##collection
所有集合类的根接口
### 集合和数组的对比
1. 长度：
2. 数据类型：集合只能放引用数据类型
3. 数组只能存放同一种元素，而集合可以存放不同类型的元素

* 增加操作
	add(E e) 
	确保此集合包含指定的元素（可选操作）。  
	addAll(Collection<? extends E> c) 
	将指定集合中的所有元素添加到这个集合（可选操作）。
* 删除操作
	remove(Object o) 
	从这个集合中移除指定元素的一个实例，如果它是存在的（可选操作）。  
	removeAll(Collection<?> c) 
	删除此集合中包含的所有元素（可选操作）的所有元素（可选操作）。 
* 判断操作
	contains(Object o) 
	返回 true如果集合包含指定元素。  
	containsAll(Collection<?> c) 
	返回 true如果这个集合包含指定集合的所有元素。 
* 求集合的交集
	retainAll(Collection<?> c) 
	boolean代表前面调用此方法的集合有没有发生变化
	仅保留包含在指定集合中的这个集合中的元素（可选操作）。
* 查询操作(通过迭代器去查询元素)
	iterator() 
	返回此集合中的元素的迭代器。
	遍历集合：
	1. 创建集合对象
	2. 创建元素
	3. 将元素添加到集合中
	4. 通过集合对象的iterator()获取迭代器
	5. 不断迭代器的hasNext()区别判断集合中是否还有下一个元素
	6. 不断通过迭代器的next()去除当前元素并且将指针往下移动

## 泛型(Generic)-------接收引用数据类型
宽泛的类型<T/K/E/V>
可以定义在类中，也可以定义在接口上，还可以定义在方法上
向上边界(最大界限是class,用<T extends class>)
向下边界(最小界限是class，用<？super class>)

## List-------------有序可重复
### ArrayList
数组没有泛型这一说，所以数组中取出来的对象用Object类型来接收
网站(查询数据)：聚合数据  www.juhe.cn------------------阿里
			apistore--------------------百度

### LinkedList
### Vector(同步)
##
### hashSet
先看hashCode是否相同，如果hashCode相同，再看equals是否相同，如果equals相同，认为新增元素是重复的元素，不会往集合中添加，如果equals不同，放在集合中。如果hashCode不同，就一定不是同一个元素

### TreeSet
1. 自然排序
2. 选择器排序(客户化排序)

## Map
map中有一个一一映射关系，一个key对应一个value，可以出现重复的value，但不能出现重复的key
HashTable不允许出现K或V为空的情况的，HashMap可以
LinkedHashMap，Hash保证了不重复，Linked保证了有序