# 线程的支撑知识点

## 并发和并行
1. 并行：指两个或多个时间在同一**时刻点**发生，
2. 并发：指两个或所个事件在同一个**时间段**发生

## 进程和线程
	用进程来对应应用程序，进程使多任务成为了可能（宏观角度）
	线程是进程中的子模块，一个进程中可能有多个线程
	进程是指运行中的应用程序，每一个进程都有自己独立的内存空间。
	线程是指进程中的一个执行流程
	Java程序中默认会有主线程(main线程，也叫ui线程)和垃圾回收器线程，Java是单线程编程模型，因此在进行UI编程时，将耗时操作放在子线程中进行，以免造成阻塞主线程。
	阈值<------阀值(不正宗)

## 操作系统
	抢占式操作系统：JVM
	分时操作系统：cpu执行权平均分配给每个进程



### 同步锁是什么：
	对于非静态方法，同步锁是this
	对于静态方法，同步锁是类的类(所争夺资源的类的字节码文件)，与反射有关的那个








# 线程
## 线程的创建和启动
### 创建
1. 扩展java.lang.Thread类
	Thread类代表线程类，有两个最主要的方法
		1. run()-----包含线程运行时所执行的代码
		2. start()-----用于启动线程
		用户的线程类只要继承Thread类，覆盖Thread中的run()方法即可
			1. 主线程和用户自定义的线程并发运行
			2. 多个线程共享同一个对象的实例变量
			3. 不要随便覆盖Thread类的start()方法
			4. 一个线程只能被启动一次
2. 实现Runnable接口

## 线程的状态转换
1. 新建状态：用new语句创建的线程对象处于新建状态，此时它和其它Java对象一样，仅仅在堆区中被分配了内存
2. 就绪状态：当线程对象被创建后，其他线程调用它的start()方法，该线程就进入就绪状态，Java虚拟机回味它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，等待获得CPU的使用权。
3. 运行状态：处于这个状态的线程占用CPU，执行程序代码。在并发运行环境中，如果计算机只有一个CPU，那么任何时刻只会有一个线程处于这个状态。如果计算机有多个CPU，那么同一时刻可以让几个线程占用不同的CPU，使他们都处于运行状态。只有处于就绪状态的线程才有机会转到运行状态。
4. 阻塞状态：阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU，直到线程重新进入就绪状态，他才有机会转到运行状态。
	阻塞状态分为以下3种：
		1. 位于对象阻塞池中的阻塞状态：当线程处于运行状态时，如果执行了某个对象的wait()方法，Java虚拟机就会把线程放到这个对象的等待池中。
		2. 位于对象锁池中的阻塞状态：当线程处于运行状态，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java虚拟机就会把这个线程放到这个对象的锁池中。
		3. 其他阻塞状态：当前线程执行了sleep()方法，或者调用了其他线程的join()方法，或者发出了I/O请求，就会进入这个状态。
	当一个线程执行System.out.println()或者System.in.read()方法时，就会发出一个I/O请求，该线程放弃CPU，进入阻塞状态。
5. 死亡状态：当线程退出run()方法时，就会进入死亡状态，该线程结束生命周期。线程有可能是正常执行完run()方法退出，也有可能是遇到异常而退出。不管线程正常结束还是异常结束，都不会对其他线程造成影响。
Thread类的isAlive()方法判断一个线程是否活着，当线程处于死亡状态或新建状态时，该方法返回false，在其余状态下，该方法返回true。

## 线程调度----按照特定的机制为多个线程分配CPU的使用权
１.　分时调度模型：让所有线程轮流获得CPU的使用权，并且平均分配每个线程占用CPU的时间片
２.　抢占式调度模型(Java虚拟机)：优先让可运行池中优先级高的线程占用CPU，如果运行池中线程的优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。
* 一个线程会因为以下原因而放弃CPU
	1. Java虚拟机让当前线程暂时放弃CPU，转到就绪状态，使其他线程获得运行机会
	2. 当前线程因为某些原因进入阻塞状态
	3. 线程运行结束
** 线程的调度不是跨平台的，不仅取决于Java虚拟机，还取决于操作系统 **
* 如果希望明确地让一个线程给另一个线程运行的机会，可以采取以下办法：
1. 调整整个线程的优先级
2. 让处于运行状态的线程调用Thread.sleep()方法
3. 让处于运行状态的线程调用Thread.yield()方法
4. 让处于运行状态的线程调用另一个线程的join()方法

### 调整各个线程的优先级
所有处于就绪状态的线程根据优先级存放在可运行池中，优先级较低的线程获得较少的运行机会，优先级较高的线程获得较高的运行机会。Thread类的setPriority(int)和setPriority()方法分别用来设置优先级和读取优先级。优先级用整数表示，取值为1~10，Thread类有以下3个静态常量
* MAX_PRIORITY：取值为10，表示最高优先级
* MIN_PRIORITY：取值为1，表示最低优先级
* NORM_PRIORITY：取值为5，表示默认的优先级

**尽管Java提供了10个优先级，但它与多数操作系统都不能很好的映射。如果希望移植性好，就只使用MAX_PRIORITY、MIN_PRIORITY、NORM_PRIORITY这三个优先级**

### 线程睡眠：Thread.sleep()方法
当一个线程在运行中执行了sleep()方法，就会放弃CPU进入阻塞状态。Thread类的sleep()方法是静态的，参数为设置的睡眠时间，以毫秒为单位。线程如果在睡眠时被中断，就会收到InterruptedException异常，线程跳到异常处理代码块。

### 线程让步：Thread.yield()方法
当线程在运行中执行了Thread类的yield()静态方法，如果此时具有相同优先级的其他线程处于就绪状态，那么yield()方法将把当前运行的线程放到可运行池中并使另一个线程运行。如果没有相同优先级的可运行进程，则yield()方法什么也不做。

sleep()方法和yield()方法都是Thread类的静态方法，都会使当前处于运行状态的线程放弃CPU，把运行机会让给别的线程，两者区别：
1. sleep()方法会给其他线程运行的机会，而不考虑其他线程的优先级，因此会给较低优先级线程一个运行的机会；yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。
2. 当线程执行了sleep()方法后，将转到阻塞状态，当线程执行了yield()方法，将转到就绪状态
3. sleep()方法声明抛出InterruptedException异常，而yield()方法没有声明抛出任何异常
4. sleep()方法比yield()方法具有更好的可移植性。不能依靠yield()方法来提高程序的并发性能。对于大多数程序员来说，yield()方法的唯一用途是在测试期间人为地提高程序的并发性能，以帮助发现一些隐藏的错误。

### 等待其他线程结束：join()
* 当前运行的线程可以调用另一个线程的join()方法，当前运行的线程将转到阻塞状态，直至另一个线程运行结束，他才恢复运行。
**线程恢复运行，指线程从阻塞状态转到就绪状态，在这个状态就能获得运行机会**

## 获得当前线程对象的引用
* Thread类的currentThread()静态方法返回当前线程对象的引用。

## 后台线程
* 定义：
	后台线程指为其他线程提供服务的线程，也称为守护线程。
* 特点：
	后台线程与前台线程相伴相随，只有所有前台线程都结束生命周期，后台线程才会结束生命周期。只要有一个前台线程没有运行结束，后台线程就不会结束生命周期。
* 主线程默认情况下是前台线程

**使用后台线程注意以下几点**
1. Java虚拟机所能保证的是，当所有前台进程运行结束时，加入后台线程还在运行，Java虚拟机就会终止后台线程。此外，后台线程是否一定在前台线程的后面结束生命周期，还取决于程序的实现。
2. 只有在线程启动前(即调用start()方法前)，才能把它设置为后台线程，如果线程启动后，再调用这个线程的setDaemon()方法，就会导致IllegalThreadStateException异常
3. 由前台线程创建的线程在默认情况下仍然是前台线程，由后台线程创建的线程在默认情况下仍然是后台线程。

## 定时器Timer


## 线程的同步

