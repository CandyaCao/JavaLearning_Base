# 类的加载、连接和初始化
## JVM和类
```
    当调用java命令运行某个java程序时，该命令启动一个java虚拟机进程，不管该java程序多复杂，该程序启动了多少个线程，他们都处于一个java虚拟机进程里。同一个JVM的所有线程，变量都处于同一个进程中，它们都使用该JVM进程的内存区。

    当系统出现以下情况时，JVM进程将被终止：
    * 程序运行到最后正常结束
    * 程序运行到使用System.exit()或Runtime.getRuntime().exit()代码处结束程序
    * 程序在执行过程中遇到未捕获的异常或错误而结束
    * 程序所在平台强制结束了JVM进程
```
## 类的加载
```
    当程序主动使用某个类时，如果该类未被加载到内存中，则系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或类初始化。

    类加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。

    类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加被称为系统类加载器。另外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。

    通过使用不同的类加载器，可以从不同来源加载类的二进制数据，如下：
    * 从本地文件系统加载class文件
    * 从JAR包加载class文件，如JDBC编程时用到的数据库驱动类就放到JAR文件中，JVM可以从JAR文件中直接加载该class文件。
    * 通过网络加载class文件
    * 把一个java源文件动态编译，并进行加载
    类加载器无需等到“首次使用”该类时才加载该类，java虚拟机允许系统预先加载某些类。
```
## 类的连接
```
    当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶负责把类的二进制数据合并到JRE。

    类连接又可分为如下三个阶段：
    （1）验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
    （2）准备：类准备阶段则负责为类的类变量分配内，并设置默认初始值
    （3）解析：将类的二进制数据中的符号引用替换成直接引用
```
## 类的初始化
```
    在类的初始化阶段，虚拟机负责对类进行初始化，主要就是对类变量进行初始化，在java类中对类变量指定初始有两种方式：1）声明类变量时指定初始值；2）使用静态初始块为类变量指定初始值。

    JVM初始化一个类包含以下几个步骤：
    1. 假如这个类还没有被加载和连接，则程序先加载和连接该类
    2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
    3. 假如类中有初始化语句，则系统依次执行这些初始化语句
```
## 类初始化的时机
```
    当java程序首次通过下面6种方式来使用某个类和接口时，系统就会初始化该类和接口：
    > 创建类的实例。为某个类创建实例的方式包括：使用new操作符来创建实例；通过反射来创建实例；通过反序列化的方式创建实例
    > 调用某个类的类方法(静态方法)
    > 访问某个类或接口的类变量，或为该类变量赋值
    > 使用反射方式来强制创建某个类的或接口对应的java.lang.Class对象。例如：Class.forName("Person")，如果系统还未初始化Person类，则这行代码将会导致该Person类被初始化，并返回Person类对应的java.lang.Class对象
    > 初始化某个类的子类。当初始化某个类的子类时，该子类的所有父类都会被初始化
    > 直接使用java.exe命令来运行某个主类。当运行某个主类时，程序初始化该主类

    除此之外，以下几种情况需要注意：
    1. 对于一个final修饰的类变量，如果该类在编译时就能被确定下来，那么这个类变量相当于“宏变量”。java编译器会在编译时直接把这个类变量出现的地方替换成它的值，因此即使程序使用该静态类变量，也不会导致该类的初始化。若不能再编译时确定其值，则需要加载类。
    2. 当使用ClassLoader类的loadClass()方法来加载某个类时，该方法只是加载该类，并不会执行该类的初始化。使用Class的forName()静态方法才会导致强制初始化该类。
```
# 类加载器
```
    类加载器负责将.class文件（可能在磁盘上，可能在网络上）加载到内存中并为之生成对应的java.lang.Class对象。
```
## 类加载器简介
```
    类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个java.lang.Class实例。一旦一个类被载入到JVM中，同一个类就不会被再次载入了。

    在java中，一个类用其全限定类名(包括包名和类名)作为标识，但在JVM中，一个类用其全限定类名和其类加载器作为唯一标识。

    当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构。   
    > Bootstrap ClassLoader      根类加载器
    > Extension ClassLoader      扩展类加载器
    > System ClassLoader         系统类加载器        

    Bootstrap ClassLoader被称为引导（也称为原始或根）类加载器，它负责加载java的核心类。如rt.jar

    Extension ClassLoader被称为扩展类加载器，负责加载JRE的扩展目录(%JAVA_HOME%/jre/lib/ext或者由java.ext,dirs系统属性指定的目录)中JAR包的类。可以为java扩展核心类以外的新功能。自己开发的jar包放到上述路径下即可。

    System ClassLoader被称为系统(也称为应用)类加载器，负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性，或CLASSPATH环境变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器，如果没有特别指定，则用户自定义的类加载器都以类加载器作为父加载路径。
```
## 类加载机制
```
JVM的类加载机制主要有如下三种：
    > 全盘负责。所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用用另一个类加载器来载入。

    > 父类委托。所谓父类委托，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。
    
    > 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区中。这就是为什么修改了Class后，必须重新启动JVM，程序所作的修改才会生效的原因。
```
## 创建并使用自定义的类加载器
```
    JVM中除根类加载器之外的所有类加载器都是ClassLoader子类的实例,开发者可以通过扩展ClassLoader的子类,并重写该ClassLoader所包含的方法来实现自定义的类加载器。

    ClassLoader类有如下两个关键方法：
    > loadClass(String name, boolean resolve)：该方法时ClassLoader的入口点，根据指定名称来加载类，系统就是调用ClassLoader的该方法来获取指定类对应的Class对象。
    > findClass(String name)：根据指定名称来查找类

    如果要实现自定义的ClassLoader,则可以通过重写以上两个方法实现。通常推荐重写findClass()方法,而不是重写loadClass()方法。loadClass()方法的执行步骤如下：
    1. 用findLoadedClass(String)来检查是否已经加载该类，如果已经加载则直接返回
    2. 在父类加载器上调用loadClass()方法，如果父类加载器为null，则使用根类加载器来加载
    3. 调用findClass(String)方法来查找类
    从上看出，重写findClass(String)方法可以避免覆盖默认类加载器的父类委托、缓冲机制两种策略。

    使用自定义的类加载器，可以实现以下功能：
    1. 执行代码前自动验证数字签名
    2. 根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译的.class文件
    3. 根据用户需求来动态地加载类
    4. 根据应用需求把其他数据以字节码的形式加载到应用中
```
## URLClassLoader类
```
    Java为ClassLoader提供了一个URLClassLoader实现类,该类也是系统类加载器和扩展类加载器的父类(父子继承关系)。URLClassLoader功能比较强大，它既可以从本地文件系统获取二进制文件来加载类，也可以从远程主机获取二进制文件来加载类。
    在应用程序中可以直接使用URLClassLoader加载类，URLClassLoader提供了如下两个构造器:
    > URLClassLoader(URL[] urls): 使用默认的父类加载器创建一个ClassLoader对象，该对象将从urls所制定的系统路径来查询并加载类
    > URLClassLoader(URL[] urls, ClassLoader parent): 使用指定的父类加载器创建一个ClassLoader对象，其他功能与上一个相同
    一旦得到了URLClassLoader对象之后，就可以调用该对象的loadClass()方法加载指定类
```
# 通过反射查看类信息
```
    java中对象在运行时有两种类型，一种是编译时类型，一种是运行时类型。程序在编译和运行时需要发现对象和类的真实信息，通常有两种解决办法。
    > 假设在编译和运行时都完全知道类型的基本信息，在这种情况下，可以用instanceof运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量
    > 编译时根本无法预知该对象和类可能属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，这就必须用反射
```
## 获得Class对象
```
    每个类被加载后，系统都会为其生成对应的Class对象，通过该Class对象就能访问到JVM中的这个类。在java程序中获得Class对象通常有如下三种方式：
    > 1. 使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名(必须添加完整包名)
    > 2. 调用某个类的class属性来获取该类对应的Class对象。例如：Person.class将会返回Person类对应的Class对象
    > 3. 调用某个类的getClass()方法。该方法是java.lang.Object类中的一个方法，所以所有的java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象

    对于第一种和第二种方式都是直接根据类来取得该类的Class对象，相比之下，第二种有以下优势：
    * 代码更安全。程序在编译就可以检查需要访问的Class对象是否存在
    * 程序性能更好。因为这种方无需调用方法，所以性能更好

```
## 从Class中获取信息
* 详情请见API
## Java 8新增的方法参数反射
# 使用反射生成并操作对象
```
    Class对象可以获得该类里的方法(由Method对象表示)、构造器(由Constructor对象表示)、成员变量(由Field表示)，这三个类都位于java.lang.reflect包下，并实现了java.lang.reflect.Member接口。程序可以通过Method对象来执行对应的方法，通过Constructor对象来调用对应的构造器创建实例，能通过Field对象直接访问对象的成员变量值。
```
## 创建对象
```
    通过反射来生成对象有如下两种方式：
    > 使用Class对象的newInstance()方法来创建该Class对象对应的实例，这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建类的实例。
    > 先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例，通过这种方式可以选择使用指定的构造器来创建实例。

    以上方法中第一种会比较常见，在很多Java EE框架中需要根据配置文件信息来创建java对象，从配置文件读取的只是某个类的字符串类名，程序需要根据该字符串来创建对应的实例，这就必须使用反射。

    如果不想使用默认构造器来创建Java对象，而想利用指定的构造器来创建Java对象，则需要利用Constructor对象，每一个Constructor对应一个构造器。为了利用指定的构造器来创建Java对象，需要如下三个步骤：
    * 获得该类的Class对象
    * 利用Class对象的getConstructor()方法来获取指定的构造器
    * 调用Constructor的newInstance()方法来创建Java对象
```
## 调用方法
## 访问成员变量值
## 操作数组
# 使用反射生成JDK动态代理
        在Java的java.lang.reflect包下提供了一个InvocationHandler接口，通过使用这个类和接口可以生成JDK动态代理类和动态代理对象。
## 使用Proxy和InvocationHandler创建动态代理
        Proxy提供了用于创建动态代理类和代理对象的静态方法，它也是所有代理类的父类。如果在程序中，为一个或多个接口动态地生成实现类，就可以使用Proxy来创建动态代理类；如果需要为一个或多个接口动态地创建实例，也可以使用Proxy来创建动态代理实例。
## 动态代理和AOP
# 反射和泛型
## 泛型与Class类
        使用Class\<T>泛型可以避免强制类型转换。
## 使用反射来获取泛型信息
        通过指定类对应的Class对象，可以获得该类里包含的所有成员变量，不管该成员变量是使用private修饰，还是使用public修饰。获得了成员变量对应的Field对象后，就可以很容易的获得该成员变量的数据类型。