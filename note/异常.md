# 复习思想
## 封装
## 继承
方法重写：一同两小一大
一同：方法名必须相同
两小：子类返回值类型必须小于等于父类的返回值类型
	   


尽量避免继承，继承打破了低耦合性

## 多态--------------子类的一种特殊情况

## 抽象类和接口
抽象类中可以有抽象方法，并且我们使用抽象类就是想在其内部去写抽象方法
行为用接口去写，表示某一类行为
能用接口的不用继承


# 异常
## 难度系数：一星半，五颗星
## 课程目标：
	没有异常处理机制的困惑
	异常体系
	如何捕获单个或多个异常以及捕获异常信息
	finally代码块
	异常分类
	抛出异常的方式
	Java7的异常新特性
  5个关键字、两个体系、两个分类
### 定义
	非正常的，不同于正常的
	本章我们研究的异常不是语法错误，语法错误编译时不能通过的，不会产生字节码文件，不可能运行
异常处理是衡量一门语言是否成熟的标准，java、c++、c#都有对异常处理的机制，c语言就没有对异常处理的机制。

异常的处理提高了程序的容错性，使程序更加健壮

### 没有异常处理机制会有什么问题
1. 使用方法的返回值来判定是否出现了异常，不能穷举出所有的异常情况
2. 处理异常流程的代码和真正的业务代码放在了一起，增大了代码的复杂性，降低了可读性。
3. 随着系统规模的不断扩大，系统的维护性越来越低

### 异常体系
	Object------>Throwable---------->error
	                      ---------->Exception
	Throwable:是Java语言中所有错误或异常的超类
	error:错误，一般描述JVM出现了异常，出现了这种错误，我们不必处理，因为已经超出了我们的处理范围，比如内存溢出，栈溢出
	Exception：异常，表明程序中出现了不正常的情况，该问题是可以修复的。
1. 不同类型的异常描述成类(异常类);

### 如何捕获单个或多个异常以及捕获异常信息
1. 该方法不做处理，抛出给更高层的人去做处理。
2. 自行通过try-catch处理
	格式：
	try{
		可能会出现异常的代码
	}catch(异常的类型){
		如果出现异常，应该怎么处理
		处理异常的代码                //将出现异常的原因，以一种用户能看懂的方式返回给用户
	}

	如果try中的代码有异常，就走到相应的catch中，
	用输出语句输出下面前两句话来展示异常信息：
	exception.getMessage()         //为什么出现异常 
	exception.toString()           //为什么出现异常+出现哪种异常
	exception.printStackTrace();    //最详细的信息(catch中必有此句话，直接调用即可)

	try-catch不能单独使用
    

    获取异常信息：
    1. exception.getMessage()；输出调用，获取异常的描述信息
    2. exception.toString();   获取异常的类型和描述信息
    3. exception.printStackTrace(); 单独调用，将打印异常的堆栈跟踪信息，既包括异常的类型，又包括异常原因，还有代码出现异常的位置。(实际开发中，用此最多)

### finally代码块
finally代码块：最终都会执行的代码块都会被放在finally代码块中
				格式：try{}catch{}finally{}
					  try{}finally{}
try代码块中会有物理操作(磁盘、网络、数据库)，都要对这些资源做关闭操作。

java-----磁盘-----文件

### Exception的分类？
根据在编译时期还是运行时期去检查异常，分为：
1. 编译时异常：CheckedException，在程序编译时期，就会检查是否有异常，如果没有异常的处理，就会报错。
2. 运行时异常：RuntimeException，在运行时期检查异常，编译时期可以不去做处理。

### 异常的抛出
1. throw：用于方法的内部，用于给调用者返回一个异常对象，具有与return一样的返回功能
2. throws：用在方法的头部，也是抛出异常
不要在finally中写return

### 异常处理的语法规则
异常处理语句主要涉及到try、catch、finally、throw、throws关键字，要正确使用它们，就必须遵守必要的语法规则。
1. try代码块不能脱离catch代码块或finally代码块而独立存在，try代码块后面至少有一个catch代码块或finally代码块。
2. try代码块后面可以有0个或多个catch代码块，还可以有0个或一个finally代码块。如果catch和finally代码块并存，则finally代码块必在catch代码块后面。
3. try代码块后面可以只跟finally代码块。
4. 在try代码块中定义的变量的作用域为try代码块，在catch代码块和finally代码块中不能访问该变量。
5. 当try代码块后面有多个catch代码块时，Java虚拟机会把实际抛出的异常对象依次和各个catch代码块生命的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块。
6. 如果一个方法可能出现必检异常，要么用try···catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误。
	判断一个方法可能会出现异常的依据：
		1. 方法中有throw语句
		2. 调用了其他方法，其他方法用throws子句声明抛出某种异常
7. throw语句后面不允许紧跟其他语句，因为这些语句永远不会被执行


## GUI

图片分为：
位图：.png   由一个又一个的像素点组成，放大了会失真
矢量图：体积小，不会失真，没法绘制复杂线条，表达的颜色比较单一

抗锯齿实现
图片找寻    iconfont
双缓存